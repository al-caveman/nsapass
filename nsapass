#!/usr/bin/python3
# nsapass  Copyright (C) <2020>  <caveman>
# licensed under GPLv3 for details read LICENSE in
# https://github.com/al-caveman/nsapass
import argparse
import os
import sys
import string
import json
import subprocess
import textwrap
import time
import secrets
import atexit
import getpass

#######################################
#                                     #
#            configs below            #
#                                     #
#######################################

# location of encrypted passwords db
DB = os.path.expanduser('~/.local/share/nsapass/db.enc')

# how many seconds should copied passwords remain in the clipboard?
COPYLIFE = 5

# what to copy in order to delete previous copy?
COPYDEL = '~\o deleted by nsapass™ o/~'

# password character sets
SETS = {
    'alphanumerics' : string.ascii_letters + string.digits,
    'hexdigits' : string.hexdigits,
    'printable' : ' ' + ''.join(c for c in string.printable if c not in
    string.whitespace),
}

# default key values
LEN = 30
SET = 'printable'

# command to load passwords db
DECCMD = ['scrypt', 'dec', '{}']

# command to save passwords db (must read plaintext from stdin)
ENCCMD = ['scrypt', 'enc', '-', '{}']

# command to paste into clipboard (must accept data from stdin)
CLIPCMD = ['xclip', '-selection', 'clipboard']

# verbosity
SHOW_DEBUG = False

# theme
THEME = {
    'BANNER' : '\33[0;90m',
    'INFO' : '\33[1;32m',
    'DEBUG' : '\33[1;33m',
    'WARN' : '\33[1;33m',
    'ERR' : '\33[1;31m',
    'CLR' : '\33[0m',
    'PASS' : '\33[0;41m', # passwords color
    'PROMPT' : '\33[0;34m',
    'KEY' : '\33[0;90m',
    'ARC' : '\33[1;31m', # true archived flag
    'NOTARC' : '\33[0;90m', # false archived flag
}

#######################################
# WARNING: normal ppl plz no looking! #
# WARNING: nude app bits ahead!       #
#             (devs only)             #
#######################################

KEY_PASS = 'password'
KEY_NOTE = 'note'
KEY_ARC = 'archived'

def printinfo(msg):
    sys.stdout.write('{INFO}*{CLR} {}\n'.format(msg, **THEME))
    sys.stdout.flush()

def printdebug(msg):
    if SHOW_DEBUG:
        sys.stdout.write('{DEBUG}D{CLR} {}\n'.format(msg, **THEME))
        sys.stdout.flush()

def printwarn(msg):
    sys.stderr.write('{WARN}*{CLR} {}\n'.format(msg, **THEME))
    sys.stderr.flush()

def printerr(msg, exit=True):
    sys.stderr.write('{ERR}*{CLR} {}\n'.format(msg, **THEME))
    sys.stderr.flush()
    if exit:
        sys.stderr.write('{ERR}*{CLR} exiting..\n'.format(**THEME))
        sys.stderr.flush()
        sys.exit(1)

def printprompt(msg):
    sys.stderr.write('{PROMPT}< {}{CLR}'.format(
        msg, **THEME))
    sys.stderr.flush()

def printout(msg):
    sys.stdout.write('  {}\n'.format(msg))
    sys.stdout.flush()
    sys.stdout.flush()

def printentry(db, username, index, showpass, showarc=True):
    """print a password entry from supplied passwords database"""
    if username == None:
        usernames = list(db)
    else:
        usernames = [username]
    for u in usernames:
        username_printed = False
        if index == None:
            indexes = range(0, len(db[u]))
        else:
            indexes = [index]
        for i in indexes:
            note = db[u][i][KEY_NOTE]
            archived = db[u][i][KEY_ARC]
            if archived:
                arcfmt = '{ARC}{}{CLR}'.format(archived, **THEME)
                if not showarc:
                    continue
            else:
                arcfmt = '{NOTARC}{}{CLR}'.format(archived, **THEME)
            if showpass:
                password = '{PASS}{}{CLR}'.format(
                    db[u][i][KEY_PASS], **THEME)
            else:
                password = '**********'
            if not username_printed:
                printout('{KEY}username:{CLR} {}'.format(u, **THEME))
                username_printed = True
            printout('  {KEY}index   :{CLR} {}'.format(i, **THEME))
            printout('  {KEY}password:{CLR} {}'.format(password, **THEME))
            printout('  {KEY}note    :{CLR} {}'.format(note, **THEME))
            printout('  {KEY}archived:{CLR} {}'.format(arcfmt, **THEME))
            printout('')

def cmd(cmd, stdin=None, stdout=subprocess.PIPE):
    """run an external command"""
    printdebug('running "{}"...'.format(' '.join(cmd)))
    c = subprocess.run(cmd, input=stdin, stdout=stdout)
    if c.returncode != 0:
        printerr('command failed')
    return c.stdout

def ask(question, minimum=None, options=None, default=None,
    required=False):
    """prompts user for normal text"""
    if minimum is not None or options is not None:
        required = True
    prompt = '{} [{}]{} '.format(question, default if default is not None
        else '', '*' if required else '')
    while True:
        printprompt(prompt)
        try:
            ans = input('')
        except EOFError:
            printerr('received end of file')
        if default is not None and ans == '':
            ans = default
        if options is not None and ans not in options:
            printwarn('bad option "{}"'.format(ans))
            printwarn('options: {}'.format(', '.join(options)))
        elif required and ans == '':
            printwarn('sorry, this field is required'.format(ans))
        elif minimum is not None:
            try:
                ans = int(ans)
                if ans < minimum:
                    printwarn('minimum is {}'.format(minimum))
                else:
                    break
            except ValueError:
                printwarn('input must be an integer')
        else:
            break
    return ans

def askpass():
    """prompts users for password"""
    while True:
        try:
            printprompt('new password: ')
            pass1 = getpass.getpass('')
            printprompt('same again  : ')
            pass2 = getpass.getpass('')
        except EOFError:
            printerr('received end of file')
        if pass1 == pass2:
            return pass1
        else:
            printwarn('passwords mismatched.  retrying...')

def genpass(gen, showpass):
    """generate password"""
    length, psetname = gen
    try:
        length = int(length)
        if length < 1:
            printerr('LEN "{}" is not positive'.format(length))
    except TypeError as e:
        printinfo(e)
        printerr('LEN "{}" is not int'.format(length))
    try:
        pset = SETS[psetname]
    except KeyError:
        printerr('bad SET "{}"'.format(psetname), exit=False)
        printerr('valid options are: {}'.format(
            ', '.join(list(SETS))))
    printinfo('making a {}-chars key from "{}"...'.format(length,
        psetname))
    while True:
        password = ''.join(secrets.choice(pset) for i in range(0, length))
        if showpass:
            printout('{PASS}{}{CLR}'.format(password, **THEME))
            ans = ask('happy?', options=['y', 'n'], default='n')
            if ans == 'y':
                break
        else:
            break
    return password

def checkquery(db, username, index, arc=None):
    """checks if supplied query (username, index) exists in the database
    db.  in case it doesnt't, it tries to guesses sensibly (by guessing
    nearest match, or by prompting for correction).  if no sensible guess
    is possible, it prompts the user.  if there is no hope even asking the
    user, it exits right here after leaving a beautiful error message
    behind"""
    if len(db) == 0:
        printerr('databse is empty')
    usernames = list(db)
    if arc is not None: # filter users without relevant entries
        usernames = [u for u in usernames
            if len([() for user in db[u] if user[KEY_ARC] == arc]) > 0]
    if username is None:
        if len(usernames) == 1:
            printwarn('only "{}" in db.  '
                "you must've wanted this one.  got it!".format(usernames[0]))
            username = usernames[0]
        else:
            username = ask('query username:', options=usernames)
    elif username not in db:
        matches = []
        for u in usernames:
            start = u.find(username)
            if start == 0:
                matches.append(u)
        if len(matches) == 1:
            printwarn('actually wanted "{}", right?  '
                'got it!'.format(matches[0]))
            username = matches[0]
        else:
            printwarn('username "{}" not found'.format(username))
            printwarn('our guesses: {}'.format(', '.join(matches)))
            username = ask('query username:', options=usernames)
    if index is None:
        indexes=[str(i) for i in range(0, len(db[username]))
            if arc is None or db[username][i][KEY_ARC] == arc]
        if len(indexes) == 1:
            printwarn('only a single index for "{}" in db'.format(
                username))
            printwarn("you must've wanted it.  got it!")
            index = int(indexes[0])
        else:
            index = ask('query index:', options=indexes)
            index = int(index)
    return username, index

def checknew(username, index, password, gen, manual, note, showpass,
    lazy=False):
    """similar to checkquery, except that this is for checking, guessing,
    and correcting new entries (not queries).  when lazy=True, it will stop
    trying to resolve Nones values (this is good for `nsapass mod` where
    None is used to indicate that no change is to be made)"""
    if username is None and not lazy:
        username = ask('new username:', required=True)
    if index is None and not lazy:
        index = ask('new index:', minimum=0, default=0)
    if password is None:
        if gen:
            password = genpass(gen, showpass)
        elif manual:
            password = askpass()
        elif not lazy:
            keytype = ask('(g)enerated, or (m)anual key?',
                options=['g', 'm'], default='g')
            if keytype == 'g':
                length = ask('key length:', minimum=1, default=LEN)
                pset = ask('key set:', options=list(SETS), default=SET)
                gen = [length, pset]
                password = genpass(gen, showpass)
            elif keytype == 'm':
                password = askpass()
    if note is None and not lazy:
        note = ask('note:')
    return username, index, password, note

def load(lock=True):
    """load passwords database"""
    if lock:
        lockDB = DB + '.lock'
        dirname = os.path.dirname(lockDB)
        os.makedirs(dirname, exist_ok=True)
        try:
            open(lockDB, 'xb').close()
        except FileExistsError:
            printerr('lock file "{}" exists'.format(lockDB), exit=False)
            printerr('delete it if no nsapass is running')
        atexit.register(os.unlink, lockDB)
    if not os.path.exists(DB):
        printwarn('"{}" not found.'.format(DB))
        printwarn('assuming empty...')
        dirname = os.path.dirname(DB)
        os.makedirs(dirname, exist_ok=True)
        return {}
    printinfo('loading db...')
    data = cmd([p.format(DB) for p in DECCMD])
    try:
        return json.loads(data)
    except json.JSONDecodeError:
        printerr('error decoding database "{}"'.format(DB))

def save(d):
    """save passwords database"""
    printinfo('saving db...')
    data = json.dumps(d, indent=4)
    tmpDB = DB + '.temp'
    try:
        cmd([p.format(tmpDB) for p in ENCCMD], stdin=data.encode())
        os.rename(tmpDB, DB)
    finally:
        try:
            os.unlink(tmpDB)
        except FileNotFoundError:
            pass

def get(username, index, arc, showpass):
    """get a password entry and store it in clipboard"""
    db = load(lock=False)
    username, index = checkquery(db, username, index, arc=arc)
    printinfo('entry to copy:')
    printentry(db, username, index, showpass)
    printinfo('copying password...')
    password = db[username][index][KEY_PASS]
    cmd(CLIPCMD, stdin=password.encode(), stdout=None)
    printinfo('deleting in {} seconds...'.format(COPYLIFE))
    try:
        time.sleep(COPYLIFE)
    except KeyboardInterrupt:
        printwarn('received keyboard interrupt.')
    printinfo('deleting...')
    cmd(CLIPCMD, stdin=COPYDEL.encode(), stdout=None)

def add(username, index, gen, manual, note, arc, showpass,
    password=None, db=None, save_db=True):
    """add a new password entry into the database"""
    username, index, password, note = checknew(username, index, password,
        gen, manual, note, showpass)
    if db is None:
        db = load()
    printinfo('adding entry...')
    entry = {KEY_PASS:password, KEY_NOTE:note, KEY_ARC:arc}
    if username in db:
        db[username].insert(index, entry)
    else:
        db[username] = [entry]
    if index >= len(db[username]):
        index = len(db[username]) - 1
    printentry(db, username, index, showpass)
    if save_db:
        save(db)

def delete(username, index, showpass, db=None, save_db=True):
    """delete a password entry from the database.  first deletion will
    archive the entry.  2nd deletion will delete it"""
    if db is None:
        db = load()
    username, index = checkquery(db, username, index)
    printinfo('entry to delete:')
    printentry(db, username, index, showpass)
    if not db[username][index][KEY_ARC]:
        printinfo('archiving entry...')
        db[username][index][KEY_ARC] = True
    else:
        printinfo('deleting...')
        del db[username][index]
        if len(db[username]) == 0:
            del db[username]
    if save_db:
        save(db)

def undelete(username, index, showpass):
    """undelete a password entry from the databases.  this removes the
    archive flag"""
    db = load()
    username, index = checkquery(db, username, index, arc=True)
    printinfo('undeleting entry...')
    printentry(db, username, index, showpass)
    if not db[username][index][KEY_ARC]:
        printerr('already undeleted')
    else:
        db[username][index][KEY_ARC] = False
    save(db)

def modify(username, index, new_username, new_index, gen, manual, note,
    showpass):
    """modify a password entry from the database"""
    db = load()
    username, index = checkquery(db, username, index)
    new_username, new_index, password, note = checknew(new_username,
        new_index, None, gen, manual, note, showpass, lazy=True)
    if {new_username, new_index, password, note} == {None}:
        printerr('no modifications specified')
    if new_username is None:
        new_username = username
    if new_index is None:
        new_index = index
    if password is None:
         password = db[username][index][KEY_PASS]
    if note is None:
         note = db[username][index][KEY_NOTE]
    arc = db[username][index][KEY_ARC]
    # case where entry will be gone, and indexes may shift.  so we may need
    # to adjust new_index if so
    if arc:
        if new_index > index:
            new_index -= 1
    delete(username, index, showpass, db=db, save_db=False)
    add(new_username, new_index, None, None, note, arc, showpass,
        password=password, db=db, save_db=False)
    save(db)

def view(showarc, showpass):
    """lists password entries from the database"""
    db = load(lock=False)
    printentry(db, None, None, showpass, showarc=showarc)

def chpass():
    """re-encrypt the database with a new password"""
    db = load(lock=True)
    save(db)

# parse arguments
# commands are specified by their name, list of command arguments, and
# extra named arguments for `add_parser`.
# arguments are specified by their named arguments to `add_argument`.
# 'PASSWORD' stands for `[-g LEN SET | -m]` and is handled separately.
allcmds = [
    ['get', ['username','index','-a','-z'],
     {'help':'load a password to clipboard'}],
    ['add', ['-a','-z','PASSWORD','-u','-i','-n'],
     {'help':'add an entry'}],
    ['del', ['username','index','-z'],
     {'help':'delete an entry'}],
    ['undel', ['username','index','-z'],
     {'help':'delete an entry'}],
    ['mod', ['username','index','-z','PASSWORD','-u','-i','-n'],
     {'help':'modify an entry'}],
    ['view', ['-a','-z'],
     {'help':'view entries'}],
    ['chpass', [],
     {'help':"change databases's password"}]
]
allargs = {
    'username':
        {'metavar':'USERNAME', 'type':str, 'nargs':'?',
            'help':'query a username'},
    'index':
        {'metavar':'INDEX', 'type':int, 'nargs':'?',
            'help':"query by entry's position"},
    '-a': {'action':'store_true', 'help':'work on the archive'},
    '-z': {'action':'store_true', 'help':'show passwords'},
    '-u': {'metavar':'USERNAME', 'type':str, 'help':'new username'},
    '-i': {'metavar':'INDEX', 'type':int, 'help':'new index'},
    '-n': {'metavar':'NOTE', 'type':str, 'help':'new note'},
}
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title='commands', dest='command')
for cmd_name, cmd_args, cmd_named in allcmds :
    subp = subparsers.add_parser(cmd_name, **cmd_named)
    for arg in cmd_args:
        if arg == 'PASSWORD':
            muex = subp.add_mutually_exclusive_group()
            muex.add_argument('-g', metavar=('LEN', 'SET'),
                nargs=2, type=str,
                help='generate a new LEN-long password from SET')
            muex.add_argument('-m', action='store_true',
                help='manually define password')
        else:
            subp.add_argument(arg, **allargs[arg])
args = parser.parse_args()

# dispatcher
banner = """{BANNER}\
nsapass™ — all your schlüssel are safely stored with us!™
licensed under teh GNU GPLv3.

for a copy of the LICENSE file, the README file, bug reports, feature
requests, and much MUCH more free and tax-exempt awesomness, visit our
project's page: https://github.com/al-caveman/nsapass !

for permanent settings edit the file "{}".
───────────────────────────────────────────────────────────────────────
{CLR}""".format(sys.argv[0], **THEME)
try:
    if args.command is None:
        sys.stderr.write(banner)
        parser.print_help()
    elif args.command == 'get':
        get(args.username, args.index, args.a, args.z)
    elif args.command == 'add':
        add(args.u, args.i, args.g, args.m, args.n, args.a, args.z)
    elif args.command == 'del':
        delete(args.username, args.index, args.z)
    elif args.command == 'undel':
        undelete(args.username, args.index, args.z)
    elif args.command == 'mod':
        modify(args.username, args.index, args.u, args.i, args.g, args.m,
            args.n, args.z)
    elif args.command == 'view':
        view(args.a, args.z)
    elif args.command == 'chpass':
        chpass()
except KeyboardInterrupt:
    printwarn('received keyboard interrupt.')
    printwarn('exiting...')
