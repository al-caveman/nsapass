#!/usr/bin/python3
# nsapass  Copyright (C) <2020>  <caveman>
# licensed under GPLv3 for details read LICENSE in
# https://github.com/al-caveman/nsapass
import argparse
import os
import sys
import string
import json
import subprocess
import textwrap
import time
import secrets
import atexit
import getpass

#######################################
#                                     #
#            configs below            #
#                                     #
#######################################

# location of encrypted passwords db
DB = os.path.expanduser('~/.local/share/nsapass/db.enc')

# how many seconds should copied passwords remain in the clipboard?
COPYLIFE = 5

# what to copy in order to delete previous copy?
COPYDEL = '~\o deleted by nsapass™ o/~'

# password character sets
SETS = {
    'alphanumerics' : string.ascii_letters + string.digits,
    'hexdigits' : string.hexdigits,
    'printable' : ' ' + ''.join(c for c in string.printable if c not in
    string.whitespace),
}

# default key values
LEN = 30
SET = 'printable'

# command to load passwords db
DECCMD = ['scrypt', 'dec', '{}']

# command to save passwords db (must read plaintext from stdin)
ENCCMD = ['scrypt', 'enc', '-', '{}']

# command to paste into clipboard (must accept data from stdin)
CLIPCMD = ['xclip', '-selection', 'clipboard']

# verbosity
SHOW_DEBUG = False

# theme
THEME = {
    'BANNER' : '\33[0;90m',
    'INFO' : '\33[1;32m',
    'DEBUG' : '\33[1;33m',
    'WARN' : '\33[1;33m',
    'ERR' : '\33[1;31m',
    'CLR' : '\33[0m',
    'PASS' : '\33[0;41m', # passwords color
    'PROMPT' : '\33[0;34m',
    'KEY' : '\33[0;90m',
}

#######################################
# WARNING: normal ppl plz no looking! #
# WARNING: nude app bits ahead!       #
#             (devs only)             #
#######################################

KEY_PASS = 'password'
KEY_NOTE = 'note'

def printinfo(msg):
    sys.stdout.write('{INFO}*{CLR} {}\n'.format(msg, **THEME))
    sys.stdout.flush()

def printdebug(msg):
    if SHOW_DEBUG:
        sys.stdout.write('{DEBUG}D{CLR} {}\n'.format(msg, **THEME))
        sys.stdout.flush()

def printwarn(msg):
    sys.stderr.write('{WARN}*{CLR} {}\n'.format(msg, **THEME))
    sys.stderr.flush()

def printerr(msg, exit=True):
    sys.stderr.write('{ERR}*{CLR} {}\n'.format(msg, **THEME))
    sys.stderr.flush()
    if exit:
        sys.stderr.write('{ERR}*{CLR} exiting..\n'.format(**THEME))
        sys.stderr.flush()
        sys.exit(1)

def printprompt(msg):
    sys.stderr.write('{PROMPT}< {}{CLR}'.format(
        msg, **THEME))
    sys.stderr.flush()

def printout(msg):
    sys.stdout.write('  {}\n'.format(msg))
    sys.stdout.flush()

def printentry(db, id, rev, showpass, showold=True):
    """print a password entry from supplied passwords database"""
    if id == None:
        ids = list(db)
    else:
        ids = [id]
    for id in ids:
        id_printed = False
        if rev == None:
            revs = range(0, len(db[id]))
        else:
            revs = [rev]
        for rev in revs:
            if db[id][rev] is None:
                continue
            note = db[id][rev][KEY_NOTE]
            if rev > 0 and not showold:
                continue
            if showpass:
                password = '{PASS}{}{CLR}'.format(
                    db[id][rev][KEY_PASS], **THEME)
            else:
                password = '**********'
            if not id_printed:
                printout('{KEY}id:{CLR} {}'.format(id, **THEME))
                id_printed = True
            printout('  {KEY}revision:{CLR} {}'.format(rev, **THEME))
            printout('  {KEY}password:{CLR} {}'.format(password, **THEME))
            printout('  {KEY}note    :{CLR} {}'.format(note, **THEME))
            printout('')

def cmd(cmd, stdin=None, stdout=subprocess.PIPE):
    """run an external command"""
    printdebug('running "{}"...'.format(' '.join(cmd)))
    c = subprocess.run(cmd, input=stdin, stdout=stdout)
    if c.returncode != 0:
        printerr('command failed')
    return c.stdout

def ask(question, minimum=None, options=None, default=None,
    required=False):
    """prompts user for normal text"""
    if minimum is not None or options is not None:
        required = True
    prompt = '{} [{}]{} '.format(question, default if default is not None
        else '', '*' if required else '')
    while True:
        printprompt(prompt)
        try:
            ans = input('')
        except EOFError:
            printerr('received end of file')
        if default is not None and ans == '':
            ans = default
        if options is not None and ans not in options:
            printwarn('bad option "{}"'.format(ans))
            printwarn('options: {}'.format(', '.join(options)))
        elif required and ans == '':
            printwarn('sorry, this field is required'.format(ans))
        elif minimum is not None:
            try:
                ans = int(ans)
                if ans < minimum:
                    printwarn('minimum is {}'.format(minimum))
                else:
                    break
            except ValueError:
                printwarn('input must be an integer')
        else:
            break
    return ans

def askpass():
    """prompts users for password"""
    while True:
        try:
            printprompt('new password: ')
            pass1 = getpass.getpass('')
            printprompt('same again  : ')
            pass2 = getpass.getpass('')
        except EOFError:
            printerr('received end of file')
        if pass1 == pass2:
            return pass1
        else:
            printwarn('passwords mismatched.  retrying...')

def genpass(gen, showpass):
    """generate password"""
    length, psetname = gen
    try:
        length = int(length)
        if length < 1:
            printerr('LEN "{}" is not positive'.format(length))
    except TypeError as e:
        printinfo(e)
        printerr('LEN "{}" is not int'.format(length))
    try:
        pset = SETS[psetname]
    except KeyError:
        printerr('bad SET "{}"'.format(psetname), exit=False)
        printerr('valid options are: {}'.format(
            ', '.join(list(SETS))))
    printinfo('making a {}-chars key from "{}"...'.format(length,
        psetname))
    while True:
        password = ''.join(secrets.choice(pset) for i in range(0, length))
        if showpass:
            printout('{PASS}{}{CLR}'.format(password, **THEME))
            ans = ask('happy?', options=['y', 'n'], default='n')
            if ans == 'y':
                break
        else:
            break
    return password

def checkquery(db, id, rev, old=None):
    """checks if supplied query (id, rev) exists in the database
    db.  in case it doesnt't, it tries to guesses sensibly (by guessing
    nearest match, or by prompting for correction).  if no sensible guess
    is possible, it prompts the user.  if there is no hope even asking the
    user, it exits right here after leaving a beautiful error message
    behind"""
    if len(db) == 0:
        printerr('databse is empty')
    ids = list(db)
    if old == True:  # filter users without old entries
        ids = [i for i in ids if len(db[i]) > 1]
    if old == False: # filter users without active entries
        ids = [i for i in ids if db[i][0] is not None]
    if id is None:
        if len(ids) == 1:
            printwarn('only "{}" in db.  '
                "you must've wanted this one.  got it!".format(ids[0]))
            id = ids[0]
        else:
            id = ask('query id:', options=ids)
    elif id not in db:
        matches = [i for i in ids if i.find(id) == 0]
        if len(matches) == 1:
            printwarn('actually wanted "{}", right?  '
                'got it!'.format(matches[0]))
            i = matches[0]
        else:
            printwarn('id "{}" not found'.format(id))
            printwarn('our guesses: {}'.format(', '.join(matches)))
            id = ask('query id:', options=ids)
    revs = [i for i in range(0, len(db[id]))
        if db[id][i] is not None and (old is None or (i > 0) == old)]
    if rev not in revs:
        if rev is not None:
            printwarn('revision "{}" is invalid'.format(rev))
        if len(revs) == 1:
            printwarn('only a single revision for "{}" in db'.format(
                id))
            printwarn("you must've wanted it.  got it!")
            rev = revs[0]
        else:
            rev = ask('query revision:', options=[str(rev) for rev in revs])
            rev = int(rev)
    return id, rev

def checknew(id, password, gen, manual, note, showpass, lazy=False):
    """similar to checkquery, except that this is for checking, guessing,
    and correcting new entries (not queries).  when lazy=True, it will stop
    trying to resolve Nones values (this is good for `nsapass mod` where
    None is used to indicate that no change is to be made)"""
    if id is None and not lazy:
        id = ask('new id:', required=True)
    if password is None:
        if gen:
            password = genpass(gen, showpass)
        elif manual:
            password = askpass()
        elif not lazy:
            keytype = ask('(g)enerated, or (m)anual key?',
                options=['g', 'm'], default='g')
            if keytype == 'g':
                length = ask('key length:', minimum=1, default=LEN)
                pset = ask('key set:', options=list(SETS), default=SET)
                gen = [length, pset]
                password = genpass(gen, showpass)
            elif keytype == 'm':
                password = askpass()
    if note is None and not lazy:
        note = ask('note:')
    return id, password, note

def load(lock=True):
    """load passwords database"""
    if lock:
        lockDB = DB + '.lock'
        dirname = os.path.dirname(lockDB)
        os.makedirs(dirname, exist_ok=True)
        try:
            open(lockDB, 'xb').close()
        except FileExistsError:
            printerr('lock file "{}" exists'.format(lockDB), exit=False)
            printerr('delete it if no nsapass is running')
        atexit.register(os.unlink, lockDB)
    if not os.path.exists(DB):
        printwarn('"{}" not found.'.format(DB))
        printwarn('assuming empty...')
        dirname = os.path.dirname(DB)
        os.makedirs(dirname, exist_ok=True)
        return {}
    printinfo('loading db...')
    data = cmd([p.format(DB) for p in DECCMD])
    try:
        return json.loads(data)
    except json.JSONDecodeError:
        printerr('error decoding database "{}"'.format(DB))

def save(d):
    """save passwords database"""
    printinfo('saving db...')
    data = json.dumps(d, indent=4)
    tmpDB = DB + '.temp'
    try:
        cmd([p.format(tmpDB) for p in ENCCMD], stdin=data.encode())
        os.rename(tmpDB, DB)
    finally:
        try:
            os.unlink(tmpDB)
        except FileNotFoundError:
            pass

def get(id, rev, old, showpass):
    """get a password entry and store it in clipboard"""
    db = load(lock=False)
    id, rev = checkquery(db, id, rev, old=old)
    printinfo('entry to copy:')
    printentry(db, id, rev, showpass)
    printinfo('copying password...')
    password = db[id][rev][KEY_PASS]
    cmd(CLIPCMD, stdin=password.encode(), stdout=None)
    printinfo('deleting in {} seconds...'.format(COPYLIFE))
    try:
        time.sleep(COPYLIFE)
    except KeyboardInterrupt:
        printwarn('received keyboard interrupt.')
    printinfo('deleting...')
    cmd(CLIPCMD, stdin=COPYDEL.encode(), stdout=None)

def add(id, gen, manual, note, showpass,
    password=None, db=None, save_db=True):
    """add a new password entry into the database"""
    id, password, note = checknew(id, password,
        gen, manual, note, showpass)
    if db is None:
        db = load()
    printinfo('adding entry...')
    entry = {KEY_PASS:password, KEY_NOTE:note}
    if id in db:
        if db[id][0] is None:
            del deb[id][0]
        db[id].insert(0, entry)
    else:
        db[id] = [entry]
    printentry(db, id, 0, showpass)
    if save_db:
        save(db)

def delete(id, rev, showpass, db=None, save_db=True):
    """delete a password entry from the database.  first deletion will
    archive the entry.  2nd deletion will delete it"""
    if db is None:
        db = load()
    id, rev = checkquery(db, id, rev)
    printinfo('entry to delete:')
    printentry(db, id, rev, showpass)
    if rev == 0:
        printinfo('moving entry to old revision...')
        db[id].insert(0, None)
    else:
        printinfo('deleting...')
        del db[id][rev]
        if db[id] == [None]:
            del db[id]
    if save_db:
        save(db)

def undelete(id, rev, showpass):
    """undelete a password entry from the databases."""
    db = load()
    id, rev = checkquery(db, id, rev, old=True) # ensures rev != 0
    printinfo('undeleting entry...')
    printentry(db, id, rev, showpass)
    if db[id][0] is not None:
        db[id].insert(0, None)
        rev = rev + 1
    db[id][0] = db[id][rev]
    del db[id][rev]
    save(db)

def modify(id, rev, new_id, gen, manual, note, showpass):
    """modify a password entry from the database"""
    db = load()
    id, rev = checkquery(db, id, rev)
    new_id, password, note = checknew(new_id, None, gen, manual, note,
        showpass, lazy=True)
    if {new_id, password, note} == {None}:
        printerr('no modifications specified')
    if new_id is None:
        new_id = id
    if password is None:
         password = db[id][rev][KEY_PASS]
    if note is None:
         note = db[id][rev][KEY_NOTE]
    add(new_id, None, None, note, showpass,
        password=password, db=db, save_db=False)
    save(db)

def view(showold, showpass):
    """lists password entries from the database"""
    db = load(lock=False)
    printentry(db, None, None, showpass, showold=showold)

def chpass():
    """re-encrypt the database with a new password"""
    db = load(lock=True)
    save(db)

# parse arguments
# commands are specified by their name, list of command arguments, and
# extra named arguments for `add_parser`.
# arguments are specified by their named arguments to `add_argument`.
# 'PASSWORD' stands for `[-g LEN SET | -m]` and is handled separately.
allcmds = [
    ['get', ['id','rev','-o','-z'],
     {'help':'load a password to clipboard'}],
    ['add', ['id','-z','PASSWORD','-n'],
     {'help':'add an entry'}],
    ['del', ['id','rev','-z'],
     {'help':'delete an entry'}],
    ['undel', ['id','rev','-z'],
     {'help':'delete an entry'}],
    ['mod', ['id','rev','-z','PASSWORD','-u','-n'],
     {'help':'modify an entry'}],
    ['view', ['-o','-z'],
     {'help':'view entries'}],
    ['chpass', [],
     {'help':"change databases's password"}]
]
allargs = {
    'id':
        {'metavar':'ID', 'type':str, 'nargs':'?',
            'help':'query a id'},
    'rev':
        {'metavar':'REV', 'type':int, 'nargs':'?',
            'help':"query by entry's position"},
    '-o': {'action':'store_true', 'help':'work on old revisions'},
    '-z': {'action':'store_true', 'help':'show passwords'},
    '-u': {'metavar':'ID', 'type':str, 'help':'new id'},
    '-n': {'metavar':'NOTE', 'type':str, 'help':'new note'},
}
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(title='commands', dest='command')
for cmd_name, cmd_args, cmd_named in allcmds :
    subp = subparsers.add_parser(cmd_name, **cmd_named)
    for arg in cmd_args:
        if arg == 'PASSWORD':
            muex = subp.add_mutually_exclusive_group()
            muex.add_argument('-g', metavar=('LEN', 'SET'),
                nargs=2, type=str,
                help='generate a new LEN-long password from SET')
            muex.add_argument('-m', action='store_true',
                help='manually define password')
        else:
            subp.add_argument(arg, **allargs[arg])
args = parser.parse_args()

# dispatcher
banner = """{BANNER}\
nsapass™ — all your schlüssel are safely stored with us!™
licensed under teh GNU GPLv3.

for a copy of the LICENSE file, the README file, bug reports, feature
requests, and much MUCH more free and tax-exempt awesomness, visit our
project's page: https://github.com/al-caveman/nsapass !

for permanent settings edit the file "{}".
───────────────────────────────────────────────────────────────────────
{CLR}""".format(sys.argv[0], **THEME)
try:
    if args.command is None:
        sys.stderr.write(banner)
        parser.print_help()
    elif args.command == 'get':
        get(args.id, args.rev, args.o, args.z)
    elif args.command == 'add':
        add(args.id, args.g, args.m, args.n, args.z)
    elif args.command == 'del':
        delete(args.id, args.rev, args.z)
    elif args.command == 'undel':
        undelete(args.id, args.rev, args.z)
    elif args.command == 'mod':
        modify(args.id, args.rev, args.i, args.g, args.m,
            args.n, args.z)
    elif args.command == 'view':
        view(args.o, args.z)
    elif args.command == 'chpass':
        chpass()
except KeyboardInterrupt:
    printwarn('received keyboard interrupt.')
    printwarn('exiting...')
